import { future, highlight } from '@mdx-deck/themes'

export const theme = {
  ...future,
  ...highlight
}

<Head>
  <title>Slide</title>
</Head>

<h3>Performance no ReactJS / React Native</h3>
<p>Vagner Cardoso <b style={{ textDecoration: 'underline' }}>vagnercardosoweb@gmail.com</b></p>
<p>Navegue pelas setas do teclado. {`-> <-`}</p>

---

<h1>O que veremos?</h1>

<Steps>
  <span>Imutabilidade para performance</span>
  <span>Utiliza√ß√£o do React DevToools</span>
  <span>Aplica√ß√£o dos hooks para performar componentes</span>
  <span>Memoriza√ß√£o de componentes com React.memo</span>
  <span>Virtualiza√ß√£o de grandes listas de dados</span>
  <span>Code Splitting no React para Web</span>
</Steps>

---

<h3>Imutabilidade</h3>

Significa que nunca √© alterado o valor de ORIGEM
e sim ele cria um novo valor com base no antigo.

```tsx
const [projects, setProjects] = useState(['ProjectName', 'ProjectName One', 'ProjectName Two']);

// Nesse exmplo ele n√£o cria um novo valor e sim altera o existente
// com isso o react n√£o vai saber diferenciar, porque o m√©todo (push)
// ele n√£o cria um novo valor e sim altera.
projects.push('NewProject');
setProjects(users)

// Nesse exemplo ele cria um novo array com base no antigo
// e com isso o react consegue fazer a compara√ß√£o para renderizar.
setProjects([...projects, 'NewProject'])
```

---

<h3>Ferramentas de Desenvolvedor</h3>

React DevTools: Identificar gargalos na renderiza√ß√£o de componentes.

---

<p style={{fontSize: 50}}>useMemo</p>

<span>Memorizar um valor calculado dentro do componente.</span>
<span>Todo calculo que voc√™ precisa na renderiza√ß√£o voc√™ por boa pr√°tica deve usar o useMemo.</span>

---

<p style={{fontSize: 50}}>Exemplo</p>

<span>Essa vari√°vel so ir√° renderizar novamente se o estado <b>POSTS</b> mudar.</span>

```tsx
const [posts, setPosts] = useState<IPosts[]>([]);

// ...

const postFormatted = useMemo(() => {
  return posts.map(post => ({
    ...post,
    titleMin:
      post.title.length > 40
        ? post.title.substr(0, 40).concat('...')
        : post.title,
  }));
}, [posts]); // Se mudar executa novamente.

// ...

return (
  <div>
    {postFormatted.map(...)}
  </div>
);
```

---

<p style={{fontSize: 50}}>useCallback</p>

<span>Memorizar uma fun√ß√£o criada dentro do componente.</span>
<span>Voc√™ pode usar em todas fun√ß√µes sem medo o useCallback.</span>

---
<p style={{fontSize: 50}}>Exemplo</p>

<span>Ou seja essa fun√ß√£o so ir√° renderizar novamente se o <b>estado URL mudar.</b></span>

```tsx
const [url, setUrl] = useState<string>('https://api...');

// ...

const fetchPosts = useCallback(async function () {
  const response = await fetch(url);
  const responseJson = await response.json();

  setPosts(responseJson);
}, [url]); // Se mudar executa novamente.

useEffect(() => {
  fetchPosts();
}, [fetchPosts]);

// ...
```

---

<p style={{fontSize: 50}}>Reconciliation</p>

<span>A cada atualiza√ß√£o de propriedade e estado, o React reconstr√≥i a √°rvore de um elemento</span>
<span>e a compara com a anterior. Caso tenha mudado, atualiza na DOM.</span>

---

<p style={{fontSize: 50}}>E os elementos filhos?</p>

<span>Todos elementos filhos tamb√©m s√£o renderizados novamente,</span>
<span> maioria das vezes sem necessidade üò≥</span>

<p style={{margin: 20}}><b>E como resolvemos isso?</b></p>

<span>Utilizando o carinha <mark>React.memo</mark>, ele vai memorizar o componente em s√≠.</span>
<span>Ou seja, s√≥ ir√° renderizar novamente quando alguma propriedade, estado dele mudar.</span>

---

<p style={{fontSize: 50}}>Observa√ß√£o sobre <mark>React.memo</mark></p>

<span>Devemos usar o React.memo principalmente em situa√ß√µes que componentes sofrem m√∫ltiplos </span>
<span style={{marginBottom: 50}}>ciclos de renderiza√ß√£o durante o tempo de vida da aplica√ß√£o.</span>

<span>Se aplica muito bem para componentes totalmente visuais que retornam os mesmos </span>
<span>dados baseado nas propriedades e estados que recebe.</span>

---
<p style={{fontSize: 50}}>Exemplo</p>

<span>Caso use o componente em algum outro local ele s√≥ ser√° renderizado novamente </span>
<span>se as <b>propriedades</b> ou <b>estado</b> interno dele mudar, e se a do <b>PAI DELE</b> mudar ele n sofre renderiza√ß√£o.</span>

```tsx
const MyComponent = React.memo(function MyComponent(props) {
  /* s√≥ re-renderiza se as prop forem alteradas */
});
```

---

<p style={{fontSize: 50}}>Virtualizando Longas Listas</p>

<span>Como renderizar grandes listas e tabelas de dados?</span>
<span style={{marginBottom: 50}}>A virtualiza√ß√£o permite renderizar apenas os componentes que aparecem em tela.</span>

<span>Esta t√©cnica somente renderiza um pequeno conjunto de suas linhas e pode reduzir drasticamente o </span>
<span>tempo que ele leva para re-renderizar os componentes bem como o n√∫mero de n√≥s criados no DOM.</span>

---

<p style={{fontSize: 50}}>Como implementar?</p>

Existe algumas libs para esse trabalho e entre as mais populares:

<a href="https://react-window.now.sh/#/examples/list/fixed-size">react-window</a>
<a href="https://bvaughn.github.io/react-virtualized/#/">react-virtualized</a>

---

<p style={{fontSize: 50}}>Code Splitting</p>

<span>Diminuir o bundle dividindo-o em peda√ßos menores.</span>
<span>Importar fun√ß√µes ou componentes somente se precisarmos.</span>

---

<p style={{fontSize: 50}}>Import din√¢mico</p>

Segnifica que a importa√ß√£o s√≥ ir√° ocorrer no momento de alguma a√ß√£o do usu√°rio.

```tsx
const App: React.FC = () => {
  const functionName = useCallback(async () => {
    const functionImpported = await import('path');

    // utiliza√ß√£o
    functionImpported(...arguments);
  }, []);

  return (
    <button onClick={functionName} type="button">Clique aqui...</button>
  );
}

export default App;
```

---

<p style={{fontSize: 50}}>Tem como fazer com componentes?</p>

<span><b>React.lazy</b></span>
<span>Permite a voc√™ renderizar uma importa√ß√£o din√¢mica como se fosse um componente comum.</span>

<p style={{margin: 20}}></p>

<span><b>React.Suspense</b></span>
<span>Ele vai aguardar at√© que o componente ser√° montado e por fim exibe em tela.</span>

---

<p style={{fontSize: 50}}>Exemplo</p>

```tsx
import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));

const MyComponent: React.FC = () => {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```

---

Tamb√©m √© muito utilizado nas rotas da aplica√ß√£o.

```tsx
import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';

const Home = lazy(() => import('./routes/Home'));
const About = lazy(() => import('./routes/About'));

const App = () => (
  <Router>
    <Suspense fallback={<div>Loading...</div>}>
      <Switch>
        <Route exact path="/" component={Home}/>
        <Route path="/about" component={About}/>
      </Switch>
    </Suspense>
  </Router>
);
```

---

Links uteis.

<span><a href="https://github.com/vagnercardosoweb">Meu Github</a></span>
<span><a href="https://www.linkedin.com/in/vcwebnetworks">Meu Linkedin</a></span>
<span><a href="https://pt-br.reactjs.org/docs/optimizing-performance.html">Otimizando Performance</a></span>
<span><a href="https://github.com/vagnercardosoweb/performance-react-project">Link do projeto.</a></span>
<span><a href="https://github.com/vagnercardosoweb/performance-react-slider">Link do projeto do slider.</a></span>
<span><a href="https://github.com/jxnblk/mdx-deck">MDX Deck | Gerador de Apresenta√ß√µes</a></span>

Obrigado, at√© a pr√≥xima.
